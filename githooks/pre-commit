#!/usr/bin/env bash
set -euo pipefail

repo_root="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

if ! IFS= read -r -d '' _first_staged < <(git diff --cached --name-only --diff-filter=ACMRD -z); then
  exit 0
fi

has_changelog=0
other_count=0
changelog_required=0
while IFS= read -r -d '' path; do
  if [[ "$path" == "CHANGELOG.md" ]]; then
    has_changelog=1
  else
    other_count=$((other_count + 1))
  fi

  case "$path" in
    src/* | cli/* | Cargo.toml | policy.example.toml)
      changelog_required=1
      ;;
  esac
done < <(git diff --cached --name-only --diff-filter=ACMRD -z || true)

if [[ "$changelog_required" -eq 1 && "$has_changelog" -ne 1 ]]; then
  if [[ "${SAFE_FS_ALLOW_NO_CHANGELOG:-}" == "1" ]]; then
    echo "pre-commit: skipping CHANGELOG.md requirement (SAFE_FS_ALLOW_NO_CHANGELOG=1)." >&2
  else
    cat >&2 <<'EOF'
pre-commit: CHANGELOG.md must be updated in the same commit.

- Add an entry under [Unreleased] in CHANGELOG.md.
- Stage it: git add CHANGELOG.md
EOF
    exit 1
  fi
fi

if [[ "$has_changelog" -eq 1 && "$other_count" -eq 0 ]]; then
  echo "pre-commit: refusing changelog-only commit; commit the actual change together with CHANGELOG.md." >&2
  exit 1
fi

if [[ "$has_changelog" -eq 1 && "${SAFE_FS_ALLOW_CHANGELOG_RELEASE_EDIT:-}" != "1" ]]; then
  head_changelog="$(git show HEAD:CHANGELOG.md 2>/dev/null || true)"
  index_changelog="$(git show :CHANGELOG.md 2>/dev/null || true)"

  if [[ -n "${head_changelog}" && -n "${index_changelog}" ]]; then
    head_released="$(printf '%s\n' "${head_changelog}" | awk 'BEGIN{s=0} /^## \\[[0-9]/{s=1} s{print}')"
    index_released="$(printf '%s\n' "${index_changelog}" | awk 'BEGIN{s=0} /^## \\[[0-9]/{s=1} s{print}')"

    if [[ "${head_released}" != "${index_released}" ]]; then
      cat >&2 <<'EOF'
pre-commit: refusing to modify released CHANGELOG sections.

Only edit entries under [Unreleased]. Released version sections (e.g. [0.x.y]) are immutable.

If you are cutting a release and intentionally updating versioned sections, re-run with:
  SAFE_FS_ALLOW_CHANGELOG_RELEASE_EDIT=1 git commit ...
EOF
      exit 1
    fi
  fi
fi

max_rs_lines="${SAFE_FS_MAX_RS_LINES:-1000}"
if ! [[ "$max_rs_lines" =~ ^[1-9][0-9]*$ ]]; then
  echo "pre-commit: SAFE_FS_MAX_RS_LINES must be a positive integer; got: $max_rs_lines" >&2
  exit 1
fi
exempt_prefixes_raw="${SAFE_FS_MAX_RS_LINES_EXEMPT_PREFIXES:-}"
IFS=',' read -r -a exempt_prefixes <<<"${exempt_prefixes_raw}"

is_exempt_rs_path() {
  local p="${1:?}"
  for prefix in "${exempt_prefixes[@]}"; do
    # Allow commas/spaces in env var; trim leading/trailing spaces in each prefix.
    prefix="${prefix#"${prefix%%[![:space:]]*}"}"
    prefix="${prefix%"${prefix##*[![:space:]]}"}"
    [[ -z "$prefix" ]] && continue
    [[ "$p" == "$prefix"* ]] && return 0
  done
  return 1
}

offenders=()
while IFS= read -r -d '' path; do
  [[ "$path" == *.rs ]] || continue
  if is_exempt_rs_path "$path"; then
    continue
  fi
  lines="$(git show ":$path" 2>/dev/null | awk 'END{print NR}')"
  if [[ "${lines:-0}" -gt "$max_rs_lines" ]]; then
    offenders+=("$path ($lines)")
  fi
done < <(git diff --cached --name-only --diff-filter=ACMR -z || true)

if [[ "${#offenders[@]}" -gt 0 ]]; then
  cat >&2 <<EOF
pre-commit: refusing to commit oversized Rust files.

一个良好的代码仓库不应该有超过 ${max_rs_lines} 行的 Rust 文件，这意味着复杂度过度或没有良好的领域分割；请拆分模块，否则禁止提交。

以下 Rust 文件超过 ${max_rs_lines} 行：
$(printf '  - %s\n' "${offenders[@]}")

如果你确实需要临时放宽限制，可设置：
  SAFE_FS_MAX_RS_LINES=<N> git commit ...

如果你确实需要对某些目录豁免（例如生成代码/fixture），可设置：
  SAFE_FS_MAX_RS_LINES_EXEMPT_PREFIXES=path/prefix1/,path/prefix2/ git commit ...
EOF
  exit 1
fi

workspace_root=""
if [[ -f "$repo_root/Cargo.toml" ]]; then
  workspace_root="$repo_root"
fi

if [[ -z "$workspace_root" ]]; then
  echo "pre-commit: no Cargo workspace found; skipping rust fmt/check." >&2
  exit 0
fi

gate_script="$repo_root/scripts/gate.sh"
if [[ ! -x "$gate_script" ]]; then
  echo "pre-commit: missing gate script: $gate_script" >&2
  exit 1
fi

"$gate_script"
